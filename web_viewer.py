#!/usr/bin/env python3
"""
AI Agent Ideation Web Viewer

This script provides a web-based interface for browsing and viewing AI agent ideas
generated by the AI Agent Ideation Generator.
"""

import os
import re
import json
import sqlite3
import threading
import time
import random
import gc
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple
from collections import defaultdict
import markdown
from flask import Flask, render_template, request, redirect, url_for, abort, jsonify, Response

# Import the core functionality
try:
    from generate_agent_ideas import (
        load_categories, load_template, get_category_folder_name,
        get_existing_ideas, is_similar_idea, generate_idea_with_ollama,
        save_idea, get_available_models, update_index
    )
except ImportError:
    print("Error importing core functionality. Make sure generate_agent_ideas.py is in the same directory.")
    import sys
    sys.exit(1)

# Constants
REPO_PATH = os.path.dirname(os.path.abspath(__file__))
CATEGORIES_DIR = os.path.join(REPO_PATH, "by-category")
INDEX_FILE = os.path.join(REPO_PATH, "index.md")
TEMPLATES_DIR = os.path.join(REPO_PATH, "web_templates")
DB_PATH = os.path.join(REPO_PATH, "ideas.db")
DEFAULT_MODEL = "llama3.2"
MAX_RETRIES = 3  # Maximum number of retries for failed generations
RETRY_DELAY = 2  # Delay between retries in seconds

# Create Flask app
app = Flask(__name__, 
            template_folder=TEMPLATES_DIR,
            static_folder=os.path.join(TEMPLATES_DIR, "static"))

# Global variables for idea generation
generation_active = False
generation_thread = None
generation_stats = {
    "total": 0,
    "generated": 0,
    "skipped": 0,
    "errors": 0,
    "log": []
}
generation_lock = threading.Lock()

def get_db_connection():
    """Get a connection to the SQLite database."""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

def get_ideas_from_db(category_filter=None, search_query=None, sort_by="created_at", sort_order="desc", limit=None):
    """Get ideas from the database with optional filtering and sorting."""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    query = """
    SELECT i.id, i.name, i.description, c.name as category, i.file_path, i.created_at
    FROM ideas i
    JOIN categories c ON i.category_id = c.id
    """
    
    params = []
    where_clauses = []
    
    if category_filter:
        where_clauses.append("c.name = ?")
        params.append(category_filter)
    
    if search_query:
        where_clauses.append("(i.name LIKE ? OR i.description LIKE ? OR c.name LIKE ?)")
        search_term = f"%{search_query}%"
        params.extend([search_term, search_term, search_term])
    
    if where_clauses:
        query += " WHERE " + " AND ".join(where_clauses)
    
    # Add sorting
    if sort_by == "name":
        query += " ORDER BY i.name"
    elif sort_by == "category":
        query += " ORDER BY c.name"
    else:  # Default to date
        query += " ORDER BY i.created_at"
    
    query += " " + sort_order.upper()
    
    if limit:
        query += f" LIMIT {limit}"
    
    cursor.execute(query, params)
    ideas = cursor.fetchall()
    
    # Convert to list of dicts
    result = []
    for idea in ideas:
        result.append({
            'id': idea['id'],
            'name': idea['name'],
            'category': idea['category'],
            'path': idea['file_path'],
            'date': idea['created_at']
        })
    
    conn.close()
    return result

def get_categories_from_db():
    """Get all categories from the database."""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    cursor.execute("""
    SELECT c.id, c.name, c.folder_name, COUNT(i.id) as idea_count
    FROM categories c
    LEFT JOIN ideas i ON c.id = i.category_id
    GROUP BY c.id
    ORDER BY c.name
    """)
    
    categories = cursor.fetchall()
    
    # Convert to list of dicts
    result = []
    for category in categories:
        result.append({
            'id': category['id'],
            'name': category['name'],
            'folder_name': category['folder_name'],
            'count': category['idea_count']
        })
    
    conn.close()
    return result

def get_idea_from_db(idea_id=None, file_path=None):
    """Get a specific idea from the database by ID or file path."""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    if idea_id:
        cursor.execute("""
        SELECT i.id, i.name, i.description, c.name as category, i.file_path, i.created_at, i.content
        FROM ideas i
        JOIN categories c ON i.category_id = c.id
        WHERE i.id = ?
        """, (idea_id,))
    elif file_path:
        cursor.execute("""
        SELECT i.id, i.name, i.description, c.name as category, i.file_path, i.created_at, i.content
        FROM ideas i
        JOIN categories c ON i.category_id = c.id
        WHERE i.file_path = ?
        """, (file_path,))
    else:
        return None
    
    idea = cursor.fetchone()
    conn.close()
    
    if not idea:
        return None
    
    # Convert to dict
    result = {
        'id': idea['id'],
        'name': idea['name'],
        'description': idea['description'],
        'category': idea['category'],
        'path': idea['file_path'],
        'date': idea['created_at'],
        'raw_content': idea['content'],
        'content_html': markdown.markdown(idea['content'], extensions=['tables', 'fenced_code'])
    }
    
    return result

def save_idea_to_db(name, description, category, file_path, content):
    """Save a new idea to the database."""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Get category ID
    cursor.execute("SELECT id FROM categories WHERE name = ?", (category,))
    category_row = cursor.fetchone()
    
    if not category_row:
        # Create category if it doesn't exist
        folder_name = get_category_folder_name(category)
        cursor.execute(
            "INSERT INTO categories (name, folder_name) VALUES (?, ?)",
            (category, folder_name)
        )
        category_id = cursor.lastrowid
    else:
        category_id = category_row['id']
    
    # Insert idea
    cursor.execute(
        """
        INSERT INTO ideas (name, description, category_id, file_path, created_at, content)
        VALUES (?, ?, ?, ?, ?, ?)
        """,
        (name, description, category_id, file_path, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), content)
    )
    
    idea_id = cursor.lastrowid
    conn.commit()
    conn.close()
    
    return idea_id

def generate_ideas_thread(model, num_ideas, similarity_threshold, unlimited=False, specific_category=None):
    """Thread function for generating AI agent ideas."""
    global generation_active, generation_stats
    
    # Reset stats
    with generation_lock:
        generation_stats["total"] = num_ideas if not unlimited else 0
        generation_stats["generated"] = 0
        generation_stats["skipped"] = 0
        generation_stats["errors"] = 0
        generation_stats["log"] = []
    
    log_generation_message(f"Starting generation with model: {model}")
    log_generation_message(f"Similarity threshold: {similarity_threshold}")
    
    if specific_category:
        log_generation_message(f"Generating ideas for category: {specific_category}")
    else:
        log_generation_message("Generating ideas across all categories")
    
    # Load categories
    categories = load_categories()
    if not categories:
        log_generation_message("Error: No categories found")
        generation_active = False
        return
    
    # Load template
    template = load_template()
    if not template:
        log_generation_message("Error: Template not found")
        generation_active = False
        return
    
    # Get existing ideas for similarity check
    existing_ideas = get_existing_ideas()
    
    # Extract just the model name string if it's a dictionary
    if isinstance(model, dict) and 'model' in model:
        model = model['model']
    
    # Generate ideas
    count = 0
    while (count < num_ideas or unlimited) and generation_active:
        try:
            # Select category
            if specific_category:
                category = specific_category
            else:
                category = random.choice(categories)
            
            # Generate idea
            log_generation_message(f"Generating idea for category: {category}")
            
            # Try to generate with retries
            success = False
            error_message = ""
            idea_text = None
            filename = None
            
            for attempt in range(MAX_RETRIES):
                try:
                    # Note: The parameter order in generate_idea_with_ollama is (category, model, template)
                    # And it returns a tuple of (generated_text, filename)
                    idea_text, filename = generate_idea_with_ollama(category, model, template)
                    success = True
                    break
                except Exception as e:
                    error_message = str(e)
                    log_generation_message(f"Ollama API error (attempt {attempt+1}/{MAX_RETRIES}): {error_message}")
                    time.sleep(RETRY_DELAY)
            
            if not success:
                log_generation_message(f"Error generating idea with Ollama: {error_message}")
                with generation_lock:
                    generation_stats["errors"] += 1
                continue
            
            # Check for similarity
            is_similar = False
            for existing_idea in existing_ideas:
                if is_similar_idea(idea_text, existing_idea, similarity_threshold):
                    is_similar = True
                    break
            
            if is_similar:
                log_generation_message("Skipping similar idea")
                with generation_lock:
                    generation_stats["skipped"] += 1
                continue
            
            # Save idea using the filename returned by generate_idea_with_ollama
            file_path = save_idea(idea_text, category, filename)
            
            # Extract name and description for database
            name_match = re.search(r'## 1\. Assistant Name:\s*\n\s*(.+?)\s*\n', idea_text, re.DOTALL)
            name = name_match.group(1).strip() if name_match else f"Unnamed Assistant {count+1}"
            
            desc_match = re.search(r'## 2\. Short Description:\s*\n\s*(.+?)\s*\n## ', idea_text, re.DOTALL)
            description = desc_match.group(1).strip() if desc_match else ""
            
            # Get relative path for database
            rel_path = os.path.relpath(file_path, REPO_PATH)
            
            # Save to database
            save_idea_to_db(name, description, category, rel_path, idea_text)
            
            # Update existing ideas for similarity check
            existing_ideas.append(idea_text)
            
            # Update stats
            with generation_lock:
                generation_stats["generated"] += 1
            
            log_generation_message(f"Generated and saved idea: {name}")
            
            # Clean up memory
            if count % 10 == 0:
                gc.collect()
            
            count += 1
            
        except Exception as e:
            log_generation_message(f"Error: {str(e)}")
            with generation_lock:
                generation_stats["errors"] += 1
    
    # Update the index file
    try:
        update_index()
        log_generation_message("Updated index file")
    except Exception as e:
        log_generation_message(f"Error updating index: {str(e)}")
    
    log_generation_message("Generation complete")
    generation_active = False

def log_generation_message(message):
    """Log a message from the generation thread."""
    timestamp = datetime.now().strftime("%H:%M:%S")
    with generation_lock:
        generation_stats["log"].append(f"[{timestamp}] {message}")
        # Keep only the last 100 log messages
        if len(generation_stats["log"]) > 100:
            generation_stats["log"] = generation_stats["log"][-100:]

@app.route('/')
def index():
    """Render the index page with all ideas."""
    # Get filter parameters
    category_filter = request.args.get('category', '')
    search_query = request.args.get('search', '')
    sort_by = request.args.get('sort', 'created_at')
    sort_order = request.args.get('order', 'desc')
    
    # Get ideas from database
    ideas = get_ideas_from_db(
        category_filter=category_filter,
        search_query=search_query,
        sort_by=sort_by,
        sort_order=sort_order
    )
    
    # Get categories from database
    categories = get_categories_from_db()
    category_names = [c['name'] for c in categories]
    
    return render_template('index.html', 
                          ideas=ideas,
                          categories=category_names,
                          category_filter=category_filter,
                          search_query=search_query,
                          sort_by=sort_by,
                          sort_order=sort_order)

@app.route('/idea/<int:idea_id>')
def view_idea_by_id(idea_id):
    """Render a page for a specific idea by ID."""
    idea = get_idea_from_db(idea_id=idea_id)
    if not idea:
        abort(404)
    
    # Get all ideas for navigation
    all_ideas = get_ideas_from_db(sort_by="created_at", sort_order="desc")
    
    # Find current idea index
    current_index = -1
    for i, item in enumerate(all_ideas):
        if item['id'] == idea_id:
            current_index = i
            break
    
    # Get previous and next ideas for navigation
    prev_idea = all_ideas[current_index + 1] if current_index < len(all_ideas) - 1 else None
    next_idea = all_ideas[current_index - 1] if current_index > 0 else None
    
    return render_template('idea.html', 
                          idea=idea,
                          prev_idea=prev_idea,
                          next_idea=next_idea)

@app.route('/idea/<path:idea_path>')
def view_idea(idea_path):
    """Render a page for a specific idea by file path."""
    # Convert URL path to file path
    file_path = idea_path
    if not file_path.endswith('.md'):
        file_path += '.md'
    
    # Check if this is an absolute path and convert to relative if needed
    if file_path.startswith('/'):
        # Try to make it relative to the repo path
        try:
            file_path = os.path.relpath(file_path, REPO_PATH)
        except ValueError:
            # If not under REPO_PATH, keep as is
            pass
    
    idea = get_idea_from_db(file_path=file_path)
    if not idea:
        # Try to get from file system as fallback
        full_path = os.path.join(REPO_PATH, file_path)
        if os.path.exists(full_path):
            with open(full_path, 'r') as f:
                content = f.read()
            
            # Extract name
            name_match = re.search(r'## 1\. Assistant Name:\s*\n\s*(.+?)\s*\n', content, re.DOTALL)
            name = name_match.group(1).strip() if name_match else os.path.basename(file_path).replace('-', ' ').title()
            
            # Extract description
            desc_match = re.search(r'## 2\. Short Description:\s*\n\s*(.+?)\s*\n## ', content, re.DOTALL)
            description = desc_match.group(1).strip() if desc_match else ""
            
            # Extract category from path
            category_folder = os.path.dirname(file_path).split('/')[-1]
            category = category_folder.replace('-', ' ').title()
            
            idea = {
                'id': None,
                'name': name,
                'description': description,
                'category': category,
                'path': file_path,
                'date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                'raw_content': content,
                'content_html': markdown.markdown(content, extensions=['tables', 'fenced_code'])
            }
        else:
            abort(404)
    
    # Get all ideas for navigation
    all_ideas = get_ideas_from_db(sort_by="created_at", sort_order="desc")
    
    # Find current idea index
    current_index = -1
    for i, item in enumerate(all_ideas):
        if item['path'] == file_path:
            current_index = i
            break
    
    # Get previous and next ideas for navigation
    prev_idea = all_ideas[current_index + 1] if current_index < len(all_ideas) - 1 else None
    next_idea = all_ideas[current_index - 1] if current_index > 0 else None
    
    return render_template('idea.html', 
                          idea=idea,
                          prev_idea=prev_idea,
                          next_idea=next_idea)

@app.route('/categories')
def categories():
    """Render the categories page."""
    categories = get_categories_from_db()
    return render_template('categories.html', categories=categories)

@app.route('/category/<category_name>')
def category(category_name):
    """Render a page for a specific category."""
    # Convert URL format to display format
    category_display = category_name.replace('-', ' ').title()
    
    # Get ideas for this category
    ideas = get_ideas_from_db(category_filter=category_display)
    
    if not ideas:
        abort(404)
    
    return render_template('category.html', 
                          category_name=category_display,
                          ideas=ideas)

@app.route('/generate', methods=['GET', 'POST'])
def generate():
    """Render the idea generation page."""
    global generation_active, generation_thread
    
    # Get available models
    try:
        models = get_available_models()
    except Exception as e:
        models = [DEFAULT_MODEL]
    
    # Get categories for specific category generation
    categories = load_categories()
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'start' and not generation_active:
            # Get generation parameters
            model = request.form.get('model', DEFAULT_MODEL)
            num_ideas = int(request.form.get('num_ideas', 10))
            unlimited = request.form.get('unlimited') == 'on'
            similarity_threshold = float(request.form.get('similarity_threshold', 0.8))
            specific_category = request.form.get('specific_category', '')
            
            if specific_category == '':
                specific_category = None
            
            # Start generation thread
            generation_active = True
            generation_thread = threading.Thread(
                target=generate_ideas_thread,
                args=(model, num_ideas, similarity_threshold, unlimited, specific_category)
            )
            generation_thread.daemon = True
            generation_thread.start()
            
            return redirect(url_for('generate'))
        
        elif action == 'stop' and generation_active:
            # Stop generation
            generation_active = False
            return redirect(url_for('generate'))
    
    return render_template('generate.html', 
                          models=models,
                          categories=categories,
                          generation_active=generation_active,
                          generation_stats=generation_stats)

@app.route('/generation_status')
def generation_status():
    """API endpoint to get the current generation status."""
    with generation_lock:
        return jsonify(generation_stats)

@app.route('/generation_log')
def generation_log():
    """Stream the generation log as server-sent events."""
    def generate_log():
        last_log_length = 0
        while True:
            with generation_lock:
                current_log_length = len(generation_stats["log"])
                if current_log_length > last_log_length:
                    new_logs = generation_stats["log"][last_log_length:]
                    last_log_length = current_log_length
                    yield f"data: {json.dumps(new_logs)}\n\n"
            
            time.sleep(0.5)
    
    return Response(generate_log(), mimetype="text/event-stream")

def main():
    """Run the Flask app."""
    # Create templates directory if it doesn't exist
    if not os.path.exists(TEMPLATES_DIR):
        os.makedirs(TEMPLATES_DIR)
        os.makedirs(os.path.join(TEMPLATES_DIR, "static"), exist_ok=True)
    
    # Check if database exists, create if not
    if not os.path.exists(DB_PATH):
        from db_setup import create_database, import_existing_ideas
        create_database()
        import_existing_ideas()
    
    # Run the app
    app.run(host='127.0.0.1', port=5000, debug=True, threaded=True)

if __name__ == "__main__":
    main()
